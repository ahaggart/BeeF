common{
    depends{}
    namespace{}
    bindings{
        swap(layout op1, layout op2){
            set{
                op1     op2
                op2     op1
            }
        }
        get(layout source){
            # push the value at a location defined by the local layout info
            # then return the start location
            # lock closure allows us to preserve the invoker's position tacking
            lock{scope{
                layout{ start curr }
                goto{ source }
                PUSH
                goto{ start }
            }}
        }
        put(layout dest){
            lock{scope{
                layout{ start curr }
                goto{ dest }
                POP
                goto{ start }
            }} 
        }
        worm(layout start, value reach, value base, text acc){
            # apply a binary function to an accumulator and the next value in
            #   a contiguous block of data
            lock{scope{
                layout{ init curr }
                goto{ start }
                set{ start reach }
                PUSH < POP >
                set{ start base  }
                <                       # return to reach counter
                lock{
                    [-> lock{ acc } PUSH < PUSH > POP > POP <] > PUSH <
                    ^<<[_^<]>_
                }
                goto{ init }
                POP
            }}
        }
        copy(layout source, layout target){
            get( source )
            put( target )
        }
        save(layout start, value amount){
            apply(start, amount, ^>, NOP, < )
        }
        save_wipe(layout start, value amount, value clr){
            bind{ mkval to 
                < ZERO +(clr) PUSH >
            }
            apply(start, amount, ^>, mkval, <_^ )
            put( start ) # discard the leftover value
        }        
        restore(layout start, value amount){
            apply(start, amount, >, NOP, <_ )
        }
        apply(layout start,value amount,text go_fn, text there_fn, text ret_fn){
            # start  (layout): location to begin application
            # amount  (value): number of cells to apply to
            # go_fn    (text): function to apply during initial pass
            # there_fn (text): function to apply in-place after initial pass
            # ret_fn   (text): function to apply during return pass
            #
            # pattern for applying functions to a contiguous block of cells
            # -- uses force_* bindings to control data head behavior            
            lock{scope{
                layout{ init curr }
                goto{ start }
                bind{ go to force_right(go_fn, 1) }
                go(amount)
                lock{ there_fn }
                bind{ ret to force_left(ret_fn, 1) }
                ret(amount)
                goto{ init }
            }}
        }
        force_right(text fn, value amount){
            # fn        (text): text to be controlled
            # amount   (value): amount of data head movement to enforce
            #
            # creates a binding that will not affect the behavior of the passed
            # text, but will raise a lock violation if the text does not move
            # the data head right by the given amount
            # >> instructions generated by this binding are functionally
            # >> identical to the passed text, and are easily optimized out by
            # >> code compaction tools (grinder.py, etc)
            
            >(amount) lock{ <(amount) fn } 
        }
        force_left(text fn, value amount){
            # see documentation for force_right
            <(amount) lock{ >(amount) fn } 
        }
        shift3(value amount, layout op1, layout op2, layout op3){
            <(amount)
            lock{scope{
                >(amount)
                layout{ init curr }
                get( op1 )
                get( op2 )
                get( op3  )
                rebase{ 1 }
                put( op3  )
                put( op2 )
                put( op1 )
                goto{ init }
            }}
        }
    }
}