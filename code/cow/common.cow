common{
    depends{}
    namespace{}
    bindings{
        swap(layout op1, layout op2){
            set{
                op1     op2
                op2     op1
            }
        }
        get(layout source){
            # push the value at a location defined by the local layout info
            # then return the start location
            # lock closure allows us to preserve the invoker's position tacking
            lock{
                rebase{0}
                goto{source}
                PUSH
                goto{0}
            }
        }
        put(layout dest){
            lock{
                rebase{0}
                goto{dest}
                POP
                goto{0}
            }   
        }
        worm(layout offset, value reach, value base, text acc){
            lock{scope{
                rebase{ 0 }
                goto{ offset }
                set{ offset reach }
                PUSH < POP >
                set{ offset base  }
                <                       # return to reach counter
                lock{
                    [-> lock{ acc } PUSH < PUSH > POP > POP <] > PUSH <
                    ^<<[_^<]>_
                }
                goto{ 0 }
                POP
            }}
        }
        copy(layout source, layout target){
            get( source )
            put( target )
        }
        save(layout offset, value amount){
            apply(offset amount ^> NOP < )
        }
        save_wipe(layout offset, value amount, value clr){
            bind{ mkval to 
                < ZERO +(clr) PUSH >
            }
            apply(offset amount ^> mkval <_^ )
            put( offset ) # discard the leftover value
        }        
        restore(layout offset, value amount){
            apply(offset amount > NOP <_ )
        }
        apply(layout offset,value amount,text go_fn, text there_fn, text ret_fn){
            # offset (layout): offset from start location to begin application
            # amount  (value): number of cells to apply to
            # go_fn    (text): function to apply during initial pass
            # there_fn (text): function to apply in-place after initial pass
            # ret_fn   (text): function to apply during return pass
            #
            # pattern for applying functions to a contiguous block of cells
            # -- uses force_* bindings to control data head behavior
            scope{
                rebase{0}
                goto{offset}
                bind{ go to force_right(go_fn 1) }
                go(amount)
                lock{ there_fn }
                bind{ ret to force_left(ret_fn 1) }
                ret(amount)
                goto{0}
            }
        }
        force_right(text fn, value amount){
            # fn        (text): text to be controlled
            # amount   (value): amount of data head movement to enforce
            #
            # creates a binding that will not affect the behavior of the passed
            # text, but will raise a lock violation if the text does not move
            # the data head right by the given amount
            # >> instructions generated by this binding are functionally
            # >> identical to the passed text, and are easily optimized out by
            # >> code compaction tools (grinder.py, etc)
            
            >(amount) lock{ <(amount) fn } 
        }
        force_left(text fn, value amount){
            # see documentation for force_right
            <(amount) lock{ >(amount) fn } 
        }
    }
}