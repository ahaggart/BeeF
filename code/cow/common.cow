common{
    depends{}
    namespace{}
    bindings{
        swap(layout op1, layout op2){
            set{
                op1     op2
                op2     op1
            }
        }
        get(layout source){ @ locked, scoped
            # push the value at a location defined by the local layout info
            # then return the start location
            # lock closure allows us to preserve the invoker's position tracking
            layout{ start curr }
            goto{ source }
            PUSH
            goto{ start }
        }
        put(layout dest){ @ locked, scoped
            layout{ start curr }
            goto{ dest }
            POP
            goto{ start }
        }
        worm(layout start, value reach, value base, text acc){
            @ locked, scoped
            # apply a binary function to an accumulator and the next value in
            #   a contiguous block of data
            layout{ init curr }
            goto{ start }
            set{ start reach }
            PUSH < POP >
            set{ start base  }
            <                       # return to reach counter
            lock{
                [-> lock{ acc } PUSH < PUSH > POP > POP <] > PUSH <
                ^<<[_^<]>_
            }
            goto{ init }
            POP
        }
        copy(layout source, layout target){
            get( source )
            put( target )
        }
        save(layout start, value amount){
            apply(start, amount, ^>, NOP, < )
        }
        save_wipe(layout start, value amount, value clr){
            bind{ mkval to 
                < ZERO +(clr) PUSH >
            }
            apply(start, amount, ^>, mkval, <_^ )
            put( start ) # discard the leftover value
        }        
        restore(layout start, value amount){
            apply(start, amount, >, NOP, <_ )
        }
        apply(layout start,value amount,text go_fn, text there_fn, text ret_fn){
            @ locked, scoped
            # start  (layout): location to begin application
            # amount  (value): number of cells to apply to
            # go_fn    (text): function to apply during initial pass
            # there_fn (text): function to apply in-place after initial pass
            # ret_fn   (text): function to apply during return pass
            #
            # pattern for applying functions to a contiguous block of cells
            # -- uses force_* bindings to control data head behavior     

            layout{ init curr }
            goto{ start }
            bind{ go to force_right(go_fn, 1) }
            go(amount)
            lock{ there_fn }
            bind{ ret to force_left(ret_fn, 1) }
            ret(amount)
            goto{ init }
        }
        force_right(text fn, value amount){
            # fn        (text): text to be controlled
            # amount   (value): amount of data head movement to enforce
            #
            # creates a binding that will not affect the behavior of the passed
            # text, but will raise a lock violation if the text does not move
            # the data head right by the given amount
            # >> instructions generated by this binding are functionally
            # >> identical to the passed text, and are easily optimized out by
            # >> code compaction tools (grinder.py, etc)
            
            >(amount) lock{ <(amount) fn } 
        }
        force_left(text fn, value amount){
            # see documentation for force_right
            <(amount) lock{ >(amount) fn } 
        }
        shift3(value amount, layout op1, layout op2, layout op3){
            <(amount)
            lock{scope{
                >(amount)
                layout{ init curr }
                get( op1 )
                get( op2 )
                get( op3  )
                rebase{ 1 }
                put( op3  )
                put( op2 )
                put( op1 )
                goto{ init }
            }}
        }
        if_nonzero(text fn){
            PUSH
            [
                POP
                lock{ fn }
                PUSH ZERO
            ]
            POP
        }
        prep_uncall{
            ZERO PUSH
        }
        uncall{ @ locked, scoped
            # remove a call from the call stack, destroys the current cell and { +1}
            # call stacks follow a reliable format
            # 1. exit stack: exit the calling namespace into global (all zeros)
            # 2. call stack: enter the called namespace (all nonzero)
            # 3. call exit: exit the called namespace (all zero)
            # 4. caller reentry: re-enter the caller's namespace (all nonzero)

            < ZERO  +               # make a flag cell
            [> POP [<-> ZERO ] <] > # pop until something nonzero decrements the flag
            +[ POP ] < +            # remove the exit stack
            [> POP [<-> ZERO ] <] >
            +[ POP ]                # expect a spacing zero placed by invoker
        }
        uncall_half{ @ locked, scoped
            < ZERO  +               # make a flag cell
            [> POP [<-> ZERO ] <] > # pop until something nonzero decrements the flag
            +[ POP ]                # remove the exit stack
        }
        dec( layout target ){ @ scoped, locked
            layout{ init curr }
            goto{ target }
            DEC
            goto{ init }
        }
        inc( layout target ){ @ scoped, locked
            layout{ init curr }
            goto{ target }
            INC
            goto{ init }
        }
        memshiftu( value amount, layout counter ){ @ scoped
            layout{ data curr }
            goto{ counter }
            [
                rebase{ counter }
                goto{ data }
                PUSH >(amount) POP <(amount)
                goto{ counter }
                PUSH < POP DEC
            ]
        }
    }
}