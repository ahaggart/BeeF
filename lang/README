===============================================================================
Language Spec
===============================================================================
Features:
* namespaces
    * The function block architecture used by BCC allows for function
        "namespaces" of up to 255 functions. Functions occupying a
        namespace may call any other function by name within the namespace.
* modules
    * Import code from other .cow files
        * load other modules and expose their top-level namespace
        * nested namespaces may import the module and access its top-level
            namespace as if it were nested
        * functions and nested namespaces may bind keywords from imported
            modules, which will use the imported definitions when unpacking
    * preamble and postamble
        * Modules which specify a preamble and postamble can be run as
            standalone programs.
        * Preambles prep processor memory by allocating a control cell and
            loading it with the desired "entry-point" function ID
        * Postambles clean up processor memory before the program exits
        * Preamble and Postable routines only run for the root module
* functions and recursion
* debugging
    * automatic cell and stack locking (planned)
        * generates error messages at runtime when code violates important 
            conditions
* keywords:
    * rebase: inform the compiler that the current location of the data head
        should be treated as a given relative address
        * functions rebase to the current data head location on entry
        * compiler will attempt to track relative position
        * assert, rebase, goto, etc require a valid base
    * assert: assert on some condition, error on violation
        * value: assert on the value in some location
            * enables compiler to optimize under this assumption, 
                * example: when zeroing cells to make function calls,
                    compiler can fetch an asserted zero instead of using "[-]"
            * (planned) specify a range or set of values
        * stack (planned): assert on the top value of the stack
            * also enables some compiler optimizations
        * verify (planned): visit all asserted locations to manually check them
            * generates goto statements which allow VM to check locked cells
            * produces no net data head movement, which means that compression
                tools (grinder) will completely strip out move instructions
                produced for assertion verification
        * clear (planned): remove assertions at all listed locations
        * compounding (planned): make multiple value assertions in one statement
        *** compiler needs better assertion management system
        *** need to finish implementing VM locks for these to work
        *** position assertions don't really make sense, just rebase
        *** assertions may be unused if the location they assert on is not
             visited
        *** assertions are cleared when they go out of scope
    * goto: resposition the data head to the given relative location
        * clearer, more concise COW files, less prone to error than manually 
            writing ">" and "<" to reposition the data head
        * accepts relative location or layout names as destination
    * set: set the value of a cell
        * can be compounded: statement may contain multiple address-target
            pairs
        * (maybe) language support for string creation using set statements
    * create: create a value at a specified address
        * by default, will zero then increment cell to value
        * nearby assertions will be considered as "shortcuts" to value
    * layout: assign names to relative locations in the current coordinate base
        * inner text is a whitespace delimited list of position-name pairs
        * reserved names carry special meaning (planned)
            * free: unused memory location, allow compiler to optimize around
        * bindings which contain layout information allow modules to export 
            formatting information for their function calls
    * lock: marks code as having no net effect on data head position
        * wraps code block in data head position assertions to enforce
    * scope: create a scope
        * assertions and keywords bound within the scope are invisible outside
        * avoid namespace collisions or pollution by scoping bindings, etc
    * bind: bind keywords to text in the current scope
        * binding a module name will add all of its bindings to the scope
        * new keywords can be bound inline
    * panic (planned): abort the VM and print a custom message
    * value:
        * bind a name to a numeric value, which can be used as a modifier or a 
            target value in SET statements
        * ex: bind ascii alphabet to single-letter names, for easy "string" use
    * exec (planned): in-order function calling
        * unlike normal calls, exec calls happen immediately
        * implicitly segments function, stacks a call to second segment under
            call to exec'ed function
        * preserves scope across function call, but not inside it

>> { # } denotes a relative address

PLANNED:
* counting block optimization
    * current design is prone to spending excessive amounts of time repeatedly
        zeroing the cell at { 0 }
    * (maybe) assume control cell will be a lower value, 
        * zero the CC and copy to { 0 } instead of zeroing { 0 }
* pre-compiled modules
    * compile module into intermediate format and save it
        * parse tree files (pickled)
        * fully compiled files with annotations specifying entry points and 
            FCIDs
* optimize compiler
    * cache semi-resolved bindings
* namespace size management
    * automatically nest functions in overfull namespaces without changing 
        how they can be referenced
    * allow namespaces to logically group contents without worrying about
        exceeding size limit

CONVENTIONS:
* make function calls from zeroed cells
    * indexing to the next functional block will repeatedly zero then restore 
        the cell, so this will save a lot of cycles
* top level functions should make heavy use of assertion verification to prevent
    misuse or misunderstanding by importers
    * tightly controlled code is much easier to debug
    * verification code is easily optimized out

BINDING SEMANTICS:
* Bindings do not create a local scope, so they will pollute the caller's
    namespace. This allows bindings to contain layout and assertion information
    * top-level functions with complex memory footprints should have associated
        bindings which define and verify their expected layout

MODULE CONTENTS:
    * preamble:
        * Defines a closure as a module preamble. Preamble closures are run when
            the parent module is run, and are expected to prepare memory then
            call a function in the module namespace.
    * postamble:
        * Defines a closure as a module postamble. Modules running as the root
            executable will run their postamble on exit. Postambles are
            expected to clean up memory from execution.
    * depends:
        * Defines a closure as a dependency closure. Dependency closures list
            files containing modules to import from
    * namespace:
        * Defines a closure as a namespace. Namespaces may contain up to 255
            closures, which must have a namespace-unique name
    * bindings:
        * Bindings are direct text substitutions, and are associated at the
            module level. Bindings which appear in function code will be 
            resolved to the symbols they are bound to.
        * bindings may declare typed modifiers, which are passed by the caller
            and change binding behavior
            * modifier types:
                * text   -- bind a name as a keyword to caller-supplied text
                * value  -- bind a name to a number supplied by caller
                * layout -- bind a name to a relative address supplied by caller
        * Bindings may contain other bindings
        * bindings can import another module's bindings, which will be used when
            resolving the binding's text
        * Bindings may not contain function calls


===============================================================================
BUTCHER / BCC
===============================================================================
LANGUAGE ARCHITECTURE NOTES:
* makes use of one "control cell" at { -1 }

Instruction Layout:
<preamble> [ <header block> <functional blocks> <footer block> ] <postamble>
===============================================================================
Preamble:
* sets up memory for functional block execution
    * makes room for control cell (if necessary) by shifting starting cells
    * "bootloader": configures control cell to execute program entry point
        * pushes a 0 onto stack (for program exit)

===============================================================================
Header Block:
* currently doesn't do anything

===============================================================================
Counting Functional Block: 
* basic building block for function call structure
* each block decrements the control cell if it is nonzero
    * block which "zeroes" control cell is executed
    * subsequent blocks will see "zeroed" control cell and skip execution

Functional Block Prototype:
^                       push cc to stack for breathing room
[                       block container (skipped if cc is zeroed)
    _-^                 decrement cc and push back to stack
    >^[-]+^             save adjacent cell, then set to one and push to stack
    <                   return to cc 
    [                   skip block 1: skipped if cc is (now zero)
        _[-]^           overwrite stacked one to zero
    ]                 
    _                   pull stacked value (one if cc was zero, zero ow)
    >_<                 restore adjacent cell
    [                   skip block 2: skipped if cc was not zero
        _>
* FUNCTION CODE GOES HERE *
        <[-]^           zero cc (exit skip block 2)
    ]
                        (exit container)
]_                      restore cc

Execution Loop Block:
* container for a set of counting functional blocks
* at the end of one execution cycle, unpacks next function call ID (FCID),
    which will be used to select the next functional block to execute
* header: <_[
    * unloads a function call ID into the control cell
* footer: _]>
    * unloads the next function call ID into the control cell
    * pushing a null FCID causes the exec loop to exit, which acts as a
        namespace exit

Function Call Prototype:
* within skip block two, the stack top is control cell
    * we can overwrite this value if the target funcion has a higher call ID
        * run two functions in one control loop (efficiency!)
        * assembler can calculate offset and write correct value to stack
    * otherwise, do some stack magic to properly branch control flow
        * abuse the fact that cc will always be zero
            * we can use cc as free scratch space, which lets us manipulate
                the stack
            1) pop the saved cc
            2) push our own call ID
            3) push successor call ID
            4) push a zero
            * pushed zero will be popped as control cell at end of func block
            * next call ID will be loaded from stack in exec loop footer
            * skip step 2 for context handoff


===============================================================================
Footer Block:
* unpacks function call ID from stack
    * function call ID of 0 will exit control loop and execute postamble
        * functions which fail to push new call IDs will "pop" to lower
            execution context (context exit)
        * lowest execution context pushed by preamble, exits program
    * branching implemented by pushing new function call ID
        * current control context is passed to called function
    * branch-and-link implemented by pushing new call ID and own call ID
        * "creates" new execution context
        * control returns to caller function when context "exits"

* function calls create a directional dependency from the caller to the callee
    * each namespace maintains a dictionary of accessible named closures
    * each function maintains a set of names it is dependent upon
    * imported namespaces should be resolved completely before 
        resolving importing namespaces
    * resolved namespaces "export" a token for each function they contain, which
        is associated with a set of tokens in the layer that it depends upon,
        and a set of tokens depended on for each nested layer visible 
        from the namespace
    * dependency tree pruning starts at the root of the dependency tree, which 
        is the base module's preamble text
        * the base module's preamble may call one of more functions in the base 
            namespace
            * the token-dependency sets of these called functions are combined
                to form a single token "layer" for the base namespace
            * for each nested or imported namespace, a token-dependency set
                is generated from the importing layer
            * each nested namespace is then resolved into a layer, using the 
                importer's token-dependency set
    * calls to other functions in the same scope will merge callee set into caller set
    * nested dependencies should be resolved recursively
    * end goal: each namespace layer should be represented as a single subset of 
        named closures in the namespace
